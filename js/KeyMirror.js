// Generated by CoffeeScript 1.12.4
var KeyMirror, KeyMirrorProto, _add, _keys, _remove, _withKeys, applyToNew, define, has, key, value,
  slice = [].slice;

has = require("has");

define = function(obj, key, value, options) {
  if (options == null) {
    options = {};
  } else if (options === "w") {
    options = {
      writable: true
    };
  }
  options.value = value;
  return Object.defineProperty(obj, key, options);
};

KeyMirror = module.exports = function() {
  var sources;
  sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  if (!(this instanceof KeyMirror)) {
    return applyToNew(KeyMirror, sources);
  }
  define(this, "_keys", [], "w");
  define(this, "_length", 0, "w");
  return _withKeys(this, _add, sources);
};

KeyMirrorProto = {
  _add: function() {
    var sources;
    sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _withKeys(this, _add, sources);
  },
  _remove: function() {
    var sources;
    sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _withKeys(this, _remove, sources);
  },
  _replace: function() {
    var sources;
    sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    this._clear();
    return _withKeys(this, _add, sources);
  },
  _clear: function() {
    var i, key, len, ref;
    ref = this._keys;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      delete this[key];
    }
    this._keys = [];
    this._length = 0;
    return this;
  },
  _clone: function() {
    return KeyMirror(this);
  }
};

for (key in KeyMirrorProto) {
  value = KeyMirrorProto[key];
  define(KeyMirror.prototype, key, value);
}

applyToNew = function(c, args) {
  return new (c.bind.apply(c, [c].concat(args)));
};

_add = function(mirror, source, key) {
  if (has(mirror, key)) {
    return false;
  }
  mirror._length = mirror._keys.push(mirror[key] = key);
  return true;
};

_remove = function(mirror, source, key) {
  if (!has(mirror, key)) {
    return false;
  }
  delete mirror[key];
  mirror._keys.splice(mirror._keys.indexOf(key), 1);
  mirror._length--;
  return true;
};

_withKeys = function(mirror, method, sources) {
  var i, j, len, len1, ref, result, source;
  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];
    if (source == null) {
      continue;
    }
    if (typeof source === "string") {
      result = method(mirror, sources, source);
    } else {
      ref = _keys(source);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        key = ref[j];
        result = method(mirror, source, key);
      }
    }
  }
  return mirror;
};

_keys = function(source) {
  if (source instanceof Array) {
    return source;
  }
  if (source instanceof KeyMirror) {
    return source._keys;
  }
  if (source.constructor === Object) {
    return Object.keys(source);
  }
  throw TypeError("Only Arrays, Objects, and KeyMirrors are accepted.");
};
